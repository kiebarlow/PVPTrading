from flask_socketio import SocketIO
from typing import Dict, List

class GameManager:
    def __init__(self, socketio):
        self.socketio = socketio
        self.gameManagers = {}
    
    def createGameManager(self, gameId, userIds):
        self.gameManagers[gameId] = Game(self.socketio, gameId, userIds)
    
    def getGameManager(self, gameId):
        return self.gameManagers[gameId]
    
    def updatePnL(self):
        for game in self.gameManagers.values():
            game.handleNewCandle(game)
            
    def openPosition(self, gameId, userId, symbol, margin, leverage):
        self.gameManagers[gameId].openPosition(userId, symbol, margin, leverage)
class Game:
    def __init__(self, socketio: SocketIO, gameId: str, userIds: List[int]):
        self.socketio = socketio
        self.userBalances: Dict[str, float] = {}
        self.userPositions: Dict[str, Dict[str, List[dict]]] = {}  # userId -> symbol -> list of positions
        self.gameId = gameId
        self.latestCandles: Dict[str, List[dict]] = {}
        for userId in userIds:
            self.userBalances[userId] = 10000
            self.userPositions[userId] = {}

    def openPosition(self, userId: str, symbol: str, margin: float, leverage: float):
        if userId not in self.userBalances:
            self.userBalances[userId] = 10000

        if userId not in self.userPositions:
            self.userPositions[userId] = {}

        if symbol not in self.userPositions[userId]:
            self.userPositions[userId][symbol] = []

        tradePrice = self.latestCandles[symbol][-1]["price"]
        quantity = abs(margin * leverage) / tradePrice
        positionType = "long" if margin > 0 else "short"

        if self.userBalances[userId] >= abs(margin):
            self.userBalances[userId] -= abs(margin)
            
            newPosition = {
                "symbol": symbol,
                "type": positionType,
                "quantity": quantity,
                "entryPrice": tradePrice,
                "leverage": leverage,
                "margin": abs(margin)
            }
            
            self.userPositions[userId][symbol].append(newPosition)
            self.emitPortfolioUpdate(userId)
        else:
            self.socketio.emit("error", {
                "userId": userId,
                "gameId": self.gameId,
                "message": "Insufficient balance"
            }, room=self.gameId)

    def calculatePositionPnL(self, position: dict, currentPrice: float) -> float:
        priceDiff = currentPrice - position["entryPrice"]
        if position["type"] == "short":
            priceDiff = -priceDiff
        return priceDiff * position["quantity"] * position["leverage"]

    def handleNewCandle(self, symbol: str, candleData: dict):
        self.latestCandles[symbol].append(candleData)
        currentPrice = candleData["price"]

        for userId in list(self.userPositions.keys()):  # Create a copy of keys to avoid modification during iteration
            if symbol in self.userPositions[userId]:
                positions = self.userPositions[userId][symbol]
                
                # Process each position and handle potential liquidations
                remainingPositions = []
                totalPnL = 0
                
                for position in positions:
                    pnl = self.calculatePositionPnL(position, currentPrice)
                    totalPnL += pnl
                    
                    # Check if this individual position should be closed (opposite margin received)
                    if (position["type"] == "long" and pnl <= -position["margin"] * position["leverage"]) or \
                       (position["type"] == "short" and pnl <= -position["margin"] * position["leverage"]):
                        self.userBalances[userId] += position["margin"] + pnl
                    else:
                        remainingPositions.append(position)

                if remainingPositions:
                    self.userPositions[userId][symbol] = remainingPositions
                else:
                    del self.userPositions[userId][symbol]
                    if not self.userPositions[userId]:  # No positions left for this user
                        del self.userPositions[userId]

                # Handle account liquidation
                if self.userBalances[userId] <= 0:
                    self.handleLiquidation(userId)
                else:
                    self.emitPortfolioUpdate(userId)

    def handleLiquidation(self, userId: str):
        del self.userBalances[userId]
        if userId in self.userPositions:
            del self.userPositions[userId]
            
        self.socketio.emit("liquidation", {
            "userId": userId,
            "gameId": self.gameId
        }, room=self.gameId)

    def calculateTotalPortfolioValue(self, userId: str) -> float:
        if userId not in self.userBalances:
            return 0

        totalValue = self.userBalances[userId]
        
        if userId in self.userPositions:
            for symbol in self.userPositions[userId]:
                currentPrice = self.latestCandles[symbol][-1]["price"]
                for position in self.userPositions[userId][symbol]:
                    totalValue += self.calculatePositionPnL(position, currentPrice)

        return totalValue

    def emitPortfolioUpdate(self, userId: str):
        totalValue = self.calculateTotalPortfolioValue(userId)
        
        self.socketio.emit("portfolioUpdate", {
            "userId": userId,
            "gameId": self.gameId,
            "balance": self.userBalances[userId],
            "totalPortfolioValue": totalValue,
            "positions": self.userPositions.get(userId, {})
        }, room=self.gameId)